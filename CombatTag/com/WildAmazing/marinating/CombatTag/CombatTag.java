package com.WildAmazing.marinating.CombatTag;


import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.logging.*;

import org.bukkit.ChatColor;
import org.bukkit.World;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.java.JavaPlugin;

import com.matejdro.bukkit.jail.Jail;
import com.matejdro.bukkit.jail.JailAPI;


/**
 * CombatTag for Bukkit
 *
 * @author <Your Name>
 */
public class CombatTag extends JavaPlugin {
    private final CombatTagPlayerListener playerListener = new CombatTagPlayerListener(this);
    private final CombatTagEntityListener entityListener = new CombatTagEntityListener(this);
    private HashMap<String, PlayerCombatClass> PLAYERLIST = new HashMap<String, PlayerCombatClass>(); //All players should be in this list.
    JailAPI jailplugin;
    
    static String mainDirectory = "plugins/CombatTag";
    public static File CTPVPLG = new File(mainDirectory + File.separator + "CombatTag.log");
    public static File CONFIG = new File(mainDirectory + File.separator + "CombatTag.properties");
    public static File PVPLOG = new File(mainDirectory + File.separator + "CombatTag.Players");
    static Properties prop = new Properties();
    Properties logplayers = new Properties();
    Properties pvploggers = new Properties();
    private long TAGTIME = 15000; //time in milliseconds (1000 is 1)
    private long GRACEPERIOD = 20000; //time in milliseconds before players are considered penalized
    private long EXTENDEDGRACEPERIOD = 60000; //grace period for players who accidently disconnect.
    private Integer JAILTIME = 5;
    private String PENALTY = "DEATH";
    private boolean USEJAIL = false;
    private boolean INVENTORYCLEAR = true;
    private boolean LIGHTNING = false;
    private boolean DEBUG = false;
    private boolean logplayersenab = false;
    private int MAXRELOG = 1; //Number of times a player can relog during a tag
    private String MSG2PLR = "&d[CombatTag] &c $tagged &6 was executed for logging off while in combat with&c $tagger";    
    private String ITEMSDROPPEDMSG = "&d[CombatTag] &c $tagged &6 has pvp logged. His/Her items drop at your feet";
    private String TAGGERMESSAGE = "&d[CombatTag] &6Tagged:&c $tagged";
    private String TAGGEDMESSAGE ="&d[CombatTag] &6Tagged by:&c $tagger ::&6StdGracePeriod: $graceperiod seconds ::&6/ct for more info.";
    private String MSGTOPLRKILLED = "";
    private double Version = 2.5;
    public static Logger log = Logger.getLogger("Minecraft");

    public CombatTag(){
    	super();
    }
    public void onEnable() {
        log.info("[CombatTag] Operational.");
        log.addHandler(new Handler() {
      public void publish(LogRecord logRecord) {
    	  try
		  {
			  String mystring = logRecord.getMessage();
			  if(mystring.contains(" lost connection: "))
			  {
				  String myarray[] = mystring.split(" ");
				 if(myarray.length == 4)
				 {
				  String PlrQuitName = myarray[0];
				  String DisconnectMessage = myarray[3];
				  if(PlrQuitName != null)
				  {
					if(getPCC(PlrQuitName) != null)
					{
					  if(DisconnectMessage != null)
					  {
						  getPCC(PlrQuitName).setDisconnectType(DisconnectMessage);
					  }
					}
				  }
			     }
			    }
			  return;
		  }
		  catch(NullPointerException e)
		  {
		  }
      }
      public void flush() {
        }

        public void close() {
        }
      });
        getServer().getPluginManager().registerEvent(Event.Type.PLAYER_JOIN, playerListener, Event.Priority.Low, this);
        getServer().getPluginManager().registerEvent(Event.Type.PLAYER_QUIT, playerListener, Event.Priority.Low, this);
        getServer().getPluginManager().registerEvent(Event.Type.PLAYER_KICK, playerListener, Event.Priority.Normal, this);
        getServer().getPluginManager().registerEvent(Event.Type.PLAYER_RESPAWN, playerListener, Event.Priority.Monitor, this);
        getServer().getPluginManager().registerEvent(Event.Type.ENTITY_DAMAGE, (Listener) entityListener, Event.Priority.Monitor, this);
    	new File(mainDirectory).mkdir(); //directory for the config file
        if(!CONFIG.exists()){ //Make config file if it doesn't exist
        	updateprop();
            log.info("[CombatTag] New file created.");
        }
			if(!PVPLOG.exists()){
				try { 
					PVPLOG.createNewFile();
					FileOutputStream badplayers = new FileOutputStream(PVPLOG);
        			pvploggers.store(badplayers, "Do not edit this file\r\n This file is only for players who have not yet been punished by combattag.");
        			badplayers.flush();
        			badplayers.close();
        			log.info("[CombatTag] BadPlayers file created.");
        		
				}
				catch (IOException ex){
					log.warning("[CombatTag] File creation error: " + ex.getMessage());
				}
				log.info("[CombatTag] " + getDescription().getVersion() + " Loaded.");
	    }
        else {
	    	log.info("[CombatTag] "+ getDescription().getVersion() +" Detected existing config file and loading.");
	        loadProcedure();//added later
	        logit("Debug is enabled! Be ready for the spam.");

        }
			loadplayers();//get players currently online here
			if(Version < Double.parseDouble(getDescription().getVersion()))
			{
				log.info("[CombatTag] Properties file updated");
				updateprop();
			}
			loadjail();
    }
    private void loadjail() {
    	Plugin jailplug = this.getServer().getPluginManager().getPlugin("Jail");
    	if (jailplug != null)
    	{
    		this.getServer().getPluginManager().enablePlugin(jailplug);
    	    jailplugin = ((Jail) jailplug).API;
    	}
    	else
    	{
    		USEJAIL = false;
    	    //Code here will run if player don't have Jail installed.
    	    //Use that to disable features of your plugin that include Jail to prevent errors.
    	}
		
	}
	public void loadProcedure(){
    	try {
	        FileInputStream in = new FileInputStream(CONFIG); //Creates the input stream
	        prop.load(in); //loads file
	        TAGGERMESSAGE = prop.getProperty("MessageToTagger", TAGGERMESSAGE);
	        TAGGEDMESSAGE = prop.getProperty("MessageToTagged", TAGGEDMESSAGE);
	        Version = Double.parseDouble(prop.getProperty("Version", "0"));
	        logplayersenab = Boolean.parseBoolean(prop.getProperty("LogPlayers", "false"));
	        PENALTY = prop.getProperty("Penalty", "DEATH").toUpperCase();
	        USEJAIL = Boolean.parseBoolean(prop.getProperty("UseJail", "false"));
	        JAILTIME = Integer.parseInt(prop.getProperty("JailTime", "5"));
	        EXTENDEDGRACEPERIOD = Long.parseLong(prop.getProperty("Extended_Grace_Period", "60"))*1000; //To be implemented (will change time depending on disconect type)
	        TAGTIME = Long.parseLong(prop.getProperty("TagTime", "15"))*1000;
	        GRACEPERIOD = Long.parseLong(prop.getProperty("Grace_period", "15"))*1000;
	        LIGHTNING = Boolean.parseBoolean(prop.getProperty("Lightning", "False"));
	        DEBUG = Boolean.parseBoolean(prop.getProperty("Debug", "False"));
	        MSG2PLR = prop.getProperty("PvpMessage2plr", MSG2PLR);
	        ITEMSDROPPEDMSG = prop.getProperty("ItemsDroppedMsg", ITEMSDROPPEDMSG);
	        MSGTOPLRKILLED = prop.getProperty("MsgToPvPLogger", MSGTOPLRKILLED);
	        MAXRELOG = Integer.parseInt(prop.getProperty("MaxRelog", "1"));
	        in.close(); //Closes the input stream.
	        FileInputStream inplayerfile = new FileInputStream(PVPLOG);
	        pvploggers.load(inplayerfile);
	        inplayerfile.close();
    	}catch (Exception e){
    		log.severe("[CombatTag] Saving error: "+e.getMessage());
    	}
    }
    public void updateprop()
    {
    	try { 
    		CONFIG.createNewFile(); //make new file
            FileOutputStream out = new FileOutputStream(CONFIG); //for writing the file
            prop.put("Version", getDescription().getVersion().toString());
            prop.put("Extended_Grace_Period", Long.toString(EXTENDEDGRACEPERIOD/1000));
            prop.put("Debug", Boolean.toString(DEBUG));
            prop.put("LogPlayers", "false");
            prop.put("Penalty", PENALTY);
            prop.put("UseJail", Boolean.toString(USEJAIL));
            prop.put("JailTime", Integer.toString(JAILTIME));
            prop.put("MessageToTagger", TAGGERMESSAGE);
            prop.put("MessageToTagged", TAGGEDMESSAGE);
            prop.put("PvpMessage2plr", MSG2PLR);
            prop.put("ItemsDroppedMsg", ITEMSDROPPEDMSG);
            prop.put("MsgToPvPLogger", MSGTOPLRKILLED);
            prop.put("TagTime", Long.toString(TAGTIME/1000));
            prop.put("Grace_period",Long.toString(GRACEPERIOD/1000));
            prop.put("MaxRelog", Integer.toString(MAXRELOG));
            prop.put("Lightning",Boolean.toString(LIGHTNING));
            prop.store(out, " Version = Do not edit this. (It is used to determine if the properites file needs to be updated.)" +"\r\n TagTime = duration of tag" + "\r\n Grace_period = time the player has to relog (starting from the moment they logout). This time is called when they disconnect normally." +
            		"\r\n Extended_Grace_Period = time player has to relog. This time is used then the client crashes or the window is closed."
            		+ "\r\n Debug = enables debug mode (be ready for the spam)" + "\r\n PvpMessage2plr is called upon a pvp logger logging back in.\r\n It supports $tagger (person who hit the pvplogger) and $tagged (Pvplogger).\r\n It also supports color coding using the &(0-9,a-f)"
            		+ "\r\n PvpMessage1plr is nearly the same as PvpMessage1plr except it is called when the pvp logger did not log back in before the server was reloaded or restarted.\r\n It supports $tagged and &colors only."
            		+ "\r\n ItemsDroppedMsg is called when the player is considered a pvplogger(when the items would normally drop to the gound)." +
            		 "\r\n It supports $tagger,$tagged and chat colors and only send the message to the person who tagged the pvp logger, as apposed to the entire server." +
            		 "\r\n MsgToPvPlogger sends a custom message to the player who pvp logged it only supports colors." +
            		 "\r\n MaxRelog is the maximum number of times a player can relog during a tag period." +
            		 "\r\n Lightning (true or false) Strikes lightning at players location upon logging back in. \r\n Only works when penalty is set to DEATH" +
            		 "\r\n LogPlayers creates a new file with a list of pvploggers and updates whenever a player pvplogs.");
            out.flush();  
            out.close(); //save and close writer
        } catch (IOException ex) {
            log.warning("[CombatTag] File creation error: "+ex.getMessage());
        }
    }
    public void onDisable() {
    	try {
        	for (PlayerCombatClass i : PLAYERLIST.values())
        	{
        		if(i.hasPvplogged() == true)
        		{
        			pvploggers.put(i.getPlayerName(), i.getTaggedBy());
        		}
        	}
			FileOutputStream badplayers = new FileOutputStream(PVPLOG);
			pvploggers.store(badplayers, "Do not edit this file\r\n This file is only for players who have not yet been punished by combattag.");
			badplayers.flush();
			badplayers.close();
		} catch (FileNotFoundException e) {

			log.info("Combat tag has encountered error" + e.getStackTrace());
			
		} catch (IOException e) {
			log.info("Combat tag has encountered error" + e.getStackTrace());
		}

		
        log.info("[CombatTag] Out.");
    }
    public boolean checkpvplogger(String Playername)
    {
    	if(pvploggers.containsKey(Playername))
    	{
    		return true;
    	}
    	else
    	{
    		return false;
    	}
    }
    public String gettaggerfromfile(String Playername)
    {
    	if(pvploggers.containsKey(Playername))
    	{
    		return pvploggers.getProperty(Playername);
    	}
    	else
    	{
    		return "";
    	}
    }
    public void removepvplogger(String Playername)
    {
    	pvploggers.remove(Playername);
    }
    public boolean getjailenabled()
    {
    	return USEJAIL;
    }
    
    public boolean getLightning(){
    	return LIGHTNING;
    }
    public int getMaxRelog()
    {
    	return MAXRELOG;
    }
    public long getGracePeriod(){
    	return GRACEPERIOD;
    }
    public long getExtendedGracePeriod()
    {
    	return EXTENDEDGRACEPERIOD;
    }
    public String getPenalty(){
    	return PENALTY;
    }
    public void setPenalty(String s){
    	PENALTY = s;
    }
    public boolean getInventoryClear(){
    	return INVENTORYCLEAR;
    }
    public void setInventoryClear(boolean b){
    	INVENTORYCLEAR = b;
    }
    public long getTagTime()
    {
    	return TAGTIME;
    }
    public boolean isinPlayerList(String PlayerName)
    {
    	return(PLAYERLIST.containsKey(PlayerName));
    }
    public PlayerCombatClass getPCC(String PlayerName)// Retrieves PlayerCombatClass from HashMap
    {
    	if(!(PlayerName == null))
    	{
    		if(PLAYERLIST.containsKey(PlayerName))
    		{
    			return(PLAYERLIST.get(PlayerName));
    		}
    		else
    		{
    			return(null);
    		}
    	}
    	return(null);
    }
    public void addtoPCC(Player myplayer)// Adds Player to HashMap PlayerList
    {
    	PLAYERLIST.put(myplayer.getName(),new PlayerCombatClass(myplayer));
    	return;
    }
    public void logit(String stringlog)
    {
    	if (DEBUG == true){
    		log.info(stringlog);
    	}
    }
    public void loadplayers()//Loads Players upon starting up. Used for reloads and such
    {
        logit("loading all players currently in world");
        //Add all Players currently online to the PLAYERLIST
        List<World> myworlds = getServer().getWorlds();
    	for(int i = 0;myworlds.size() > i; i++)
    	{
    		List<Player> myplayers = myworlds.get(i).getPlayers();
    		for(int k = 0;myplayers.size() > k; k++)
    		{
    			addtoPCC(myplayers.get(k));
    		}
    	}
    	return;
    }
	public void killAndClean(Player p)//Kills Player and cleans inventory
	{
		msgPvpLogger(p);
		if (getPenalty().equals("DEATH")){
			p.getInventory().clear();
			ItemStack TempArmor[] = p.getInventory().getArmorContents();
			for(int i = 0; TempArmor.length > i; i++)
			{
				TempArmor[i].setTypeId(0);
			}
			p.getInventory().setArmorContents(TempArmor);
			if (getLightning())
			{
				logit("Lightning struck at " + p.getName() + "'s location");
				p.getWorld().strikeLightningEffect(p.getLocation());
			}
			logit(p.getName() + "'s inventory has been cleared and killed");
			
    		p.setHealth(0);
		}
	}
	public void jailPlayer(String Playername)
	{
		if(USEJAIL == true)
		{
			String reason = "PvPLogging";
			jailplugin.jailPlayer(Playername, JAILTIME, null, reason);
		}
	}
	public void removetaggedfromallplrs(String PlayerName)// Removes Player from all other players tagged list
	{
		for (PlayerCombatClass i : PLAYERLIST.values()){
			i.removeFromTaggedPlayers(PlayerName);
		}
		logit("Removing " + PlayerName + " from all players taged list");
		return;
	}
	public void dropitemsandclearPCCitems(String Winner, String Loser)// Drops items naturally infront of Player and removes items from ...
	{
		PlayerCombatClass PCCLoser = getPCC(Loser);
		PlayerCombatClass PCCWinner = getPCC(Winner);
			if(isPlrOnline(PCCWinner.getPlayerName()))
			{
				Player PlrWinner = getServer().getPlayer(PCCWinner.getPlayerName());//Winner by default (or  by pvp logging)
				sendMessageWinner(PlrWinner, PCCLoser.getPlayerName());
				if(getPenalty().equals("DEATH"))
				{
					
					logit("dropping " + Loser + "items at " + Winner + "'s feet");
					if(PCCLoser.getItems() != null)
					{
						for(int i = 0;PCCLoser.getItems().size() > i; i++)
						{
							PlrWinner.getWorld().dropItemNaturally(PlrWinner.getLocation(), PCCLoser.getItems().get(i));
						}
					}
				}
			}
			else
			{
				logit("Unable to get winner null returned. (winner not online)");
			}
		PCCLoser.clearItems();
		return;
	}
	public void configureTaggerAndTagged(PlayerCombatClass Tagger, PlayerCombatClass Tagged)//Configures Tagged and Tagger appropriately
	{
		if(Tagged.tagExpired())
		{
			Tagged.removeTimesReloged();
		}
		if(!(Tagger.hasTaggedPlayer(Tagged.getPlayerName())))
		{
			Tagged.setTaggedBy(Tagger.getPlayerName()); //Sets tagger as the tagger for tagged
			Tagger.addToTaggedPlayers(Tagged.getPlayerName()); //Adds Tagged player to Taggers player list
		}
		Tagged.setTagExpiration(getTagTime());// Sets the tag expiration for Tagged
	}
	
	public void announcePvPLog(String tagged, String tagger)
	{
		String Messageout = MSG2PLR;
		Messageout = Messageout.replace("$tagged", tagged);
		Messageout = Messageout.replace("$tagger", tagger);
		Messageout = Messageout.replaceAll("&([0-9a-f])", "\u00A7$1");
		String MessageoutArray[] = Messageout.split("::");
		for(String message : MessageoutArray)
		{
			getServer().broadcastMessage(message);
		}
	}
	public void sendMessageWinner(Player winner, String Loser)
	{
		 String mymessage = ITEMSDROPPEDMSG;
		 mymessage = mymessage.replace("$tagged", Loser );
		 mymessage = mymessage.replaceAll("&([0-9a-f])", "\u00A7$1");
		 String MessageoutArray[] = mymessage.split("::");
		for(String message : MessageoutArray)
		{
			winner.sendMessage(message);
		}
		 
	}
	public void msgPvpLogger(Player myPlayer)
	{
		logit("Sending message to pvp logger" + "Message: " + MSGTOPLRKILLED);
		String mymessage = MSGTOPLRKILLED;
		mymessage = mymessage.replaceAll("&([0-9a-f])", "\u00A7$1");
		String MessageoutArray[] = mymessage.split("::");
		for(String message : MessageoutArray)
		{
			myPlayer.sendMessage(message);
		}
		
	}
	public void sendLogToConsole(String PvpLogger)
	{
		log.info(PvpLogger + " has logged out during PVP.");
	}
	public void sendmessagetoDamagerandDamaged(Player damager, Player damaged) {
		String damagedmessage = TAGGEDMESSAGE;
		damagedmessage = damagedmessage.replace("$tagged", damaged.getName());
		damagedmessage = damagedmessage.replace("$tagger", damager.getName());
		damagedmessage = damagedmessage.replace("$graceperiod", String.valueOf(getGracePeriod()/1000));
		damagedmessage = damagedmessage.replaceAll("&([0-9a-f])", "\u00A7$1");
		String Messagetodamaged[] = damagedmessage.split("::");
		for(String message : Messagetodamaged)
		{
			damaged.sendMessage(message);
		}
		String damagermessage = TAGGERMESSAGE;
		damagermessage = damagermessage.replace("$tagged", damaged.getName());
		damagermessage = damagermessage.replace("$tagger", damager.getName());
		damagermessage = damagermessage.replace("$graceperiod", String.valueOf(getGracePeriod()/1000));
		damagermessage = damagermessage.replaceAll("&([0-9a-f])", "\u00A7$1");
		String Messagetodamager[] = damagermessage.split("::");
		for(String message : Messagetodamager)
		{
			damager.sendMessage(message);
		}
	}
	
	public void updatepvploggerfile(String Playername)
	{
		if(logplayersenab == true)
		{
			if(!(CTPVPLG.exists()))
			{
				try {
					CTPVPLG.createNewFile();
					FileOutputStream loglist = new FileOutputStream(CTPVPLG);
					logplayers.store(loglist, " Do not edit this file\r\n This File is a log of pvp loggers.");
					loglist.flush();
					loglist.close();
				} catch (IOException e) {
					log.severe("[CombatTag] Failed to make the pvp info file.");
				}
			}
			try{
				if(CTPVPLG.exists())
				{
					FileInputStream inlist = new FileInputStream(CTPVPLG);
					logplayers.load(inlist);
					if(logplayers.containsKey(Playername))
					{
						Integer logcount = Integer.parseInt(logplayers.getProperty(Playername, "0"));
						logcount = logcount + 1;
						logplayers.put(Playername, logcount.toString());
					}
					else
					{
						logplayers.put(Playername, "1");
					}
					inlist.close();
					//finally write the properties back to the file 
					FileOutputStream outlist = new FileOutputStream(CTPVPLG);
					logplayers.store(outlist, "Do not edit this file\r\n This File is a log of pvp loggers.");
					outlist.flush();
					outlist.close();
					logplayers.clear();
				}
			}
			catch(IOException ex)
			{
				log.severe("[CombatTag] Failed to update the pvp info file");
			}
			//create file
			//logplayers
			//check for property existing else put the property in
		}
	return;
	}
	
	public boolean isPlrOnline(String Playername)
	{
		try
		{
			Player myplayer = getServer().getPlayer(Playername);
			return myplayer.isOnline();
		}
		catch(NullPointerException e)
		{
			return false;
		}
	}
	public void updateTags(String playername, Boolean Continue_deeper)//Updates tags for players (called from onCommand)
	{
		PlayerCombatClass Tagged = getPCC(playername); //Player1 (tagged player)
		if(Tagged.isTagged())
		{
			if(Tagged.tagExpired())
			{
				if(isPlrOnline(Tagged.getPlayerName()))//If tagged is online
				{
					Tagged.removeTimesReloged();
					PlayerCombatClass Tagger = getPCC(Tagged.getTaggedBy());
					Tagged.removeTaggedBy();
					Tagger.removeFromTaggedPlayers(Tagged.getPlayerName());
					//remove tags here
				}
			}
		}
		if(Continue_deeper == true)
		{
			if(Tagged.hasTaggedPlayer())// Check to see if Player has tagged other players
			{	
				logit(Tagged.getPlayerName() + " has tagged players");
				ArrayList<String> Myarray = Tagged.getTaggedPlayers();// Temporary arraylist for deep copy
				logit("setting up iterator");
				//Make a deep copy of Myarray
				Iterator<String> itr = Myarray.iterator(); // Setup iterator
				ArrayList<String> backup = new ArrayList<String>();
				while (itr.hasNext())//Check to see if there is another element in Myarray
				{
					backup.add(itr.next());	//Copy each element in arraylist
				}
				//Deep copy finished
				Iterator<String> newitr = backup.iterator();//Setup iterator
				while(newitr.hasNext())// Check to see if there is another element in backup
				{
					String currentplayer = newitr.next();
					logit("recursive call to update tags using " + currentplayer);
					updateTags(currentplayer, false);// Recursive call for tagged player
				}
			}
		}
	}
	
	@Override
	public boolean onCommand(CommandSender sender, Command command, String commandLabel, String[] args)
	{
		if(command.getName().equalsIgnoreCase("ct") || command.getName().equalsIgnoreCase("combattag"))
		{
			if(sender instanceof Player)
			{
				if(args.length == 0)
				{
					Player CmdPlr = (Player)sender;
					PlayerCombatClass PCCPlr = getPCC(CmdPlr.getName());
					updateTags(PCCPlr.getPlayerName(),true);//Updates tags to represent most recent values
					if(PCCPlr.isTagged())
					{
						
						CmdPlr.sendMessage(ChatColor.GOLD + "You are tagged by " + ChatColor.RED +PCCPlr.getTaggedBy() + ChatColor.GOLD +" for " + PCCPlr.tagPeriodInSeconds() + " more seconds.");
						CmdPlr.sendMessage(ChatColor.GOLD + "You have " + getGracePeriod()/1000 + " seconds to relog");
						CmdPlr.sendMessage(ChatColor.GOLD + "You have " + new Integer (getMaxRelog()-PCCPlr.getTimesReloged()).toString() + " relog(s) remaining for this tag");
					}
					else
					{
						CmdPlr.sendMessage(ChatColor.GOLD + "You are not tagged.");
					}
					CmdPlr.sendMessage(ChatColor.GOLD + "You have tagged : " + ChatColor.RED +PCCPlr.TaggedList());//Sends the player a list of players he has tagged
				return true;
				}
			}
			else
			{
				log.info("Only Players can use CombatTag");
				return true;
			}
		}
		return false;
	}
	
}

